#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Oct 20 13:23:40 2018

@author: 2020shatgiskessell
"""
import cv2
import numpy as np
import scipy.signal
import math


#Node on graph
class Node:
    def __init__(self, xcoordinate= None, ycoordinate= None):
        self.xcoordinate = xcoordinate
        self.ycoordinate = ycoordinate

        
    def __repr__(self):
        return repr((self.xcoordinate, self.ycoordinate, self.h, self.g, self.cost))


class LinkedList:
    def __init__(self, first, next=()):
        self.first = first
        self.next = next


roomimg = cv2.imread("/Users/2020shatgiskessell/Desktop/Maps/medium2.jpg")

# edge detection
# ret, thresh = cv2.threshold(roomimg, 127, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C)
thresh = cv2.cvtColor(roomimg, cv2.COLOR_BGR2GRAY)
edge = cv2.Canny(thresh, 100, 200)
height,width,channels = roomimg.shape


#define the dimensions of the grid
def estimate_noise(I):

  H, W = I.shape

  M = [[1, -2, 1],
       [-2, 4, -2],
       [1, -2, 1]]

  sigma = np.sum(np.sum(np.absolute(scipy.signal.convolve2d(np.array(I), M))))

  sigma = sigma * np.sqrt(0.5 * np.pi) / (6 * (W-2) * (H-2))

  return sigma

boxsize = (math.pow(estimate_noise(edge),-0.708)* 112.32)
matrix_icrement_width = int(width/int(boxsize))
matrix_icrement_height = int(height/int(boxsize))
Matrix =  [[0 for x in range(matrix_icrement_width)] for y in range(matrix_icrement_height)] 


Nodes = []
closed_list = []
adjacancy_list = []


#CREATE STARTING AND ENDING NODES
starting_node = Node(xcoordinate = 0, ycoordinate = 15)
closed_list.append(starting_node)

ending_node = Node(xcoordinate = 17, ycoordinate = 25)
#Test endpoints include:
#(17, 18)
#(17, 25)
#(19, 0)


cv2.circle(roomimg,(ending_node.xcoordinate * int(boxsize), ending_node.ycoordinate* int(boxsize)), 5, (0,255,54), -1)


#defines what are obstacles and what are not
cut_off_point = 15
print (boxsize)
#U HAVE TO CHANGE CUT OFF POINT BASED ON EVERY IMAGE

box_num = 0
boxesdrawn = 0
for i in range (0,width, int(boxsize)):
    for j in range (0,height, int(boxsize)):
        #1. DRAW THE BLOCKS
        roi_gray = edge[j:j+int(boxsize),i:i+int(boxsize)]
        #2. FIND INTENSITY OF ROI
        roi_avg_intensity = np.mean(roi_gray)
        #3. BASED ON THAT, SEE IF ROI IS AN OBSTACLE OR NOT
        #print(box_num,"(",i,",",j,")")
        
        if roi_avg_intensity > cut_off_point:
            #DRAW RECTANGLE AROUND OBSATCLE
            
            cv2.rectangle(roomimg, (i,j), (i+int(boxsize), j+int(boxsize)),(0,0,255))

            #store top left corneer of ROI in Matrx
            Matrix[int(j/int(boxsize))][int(i/int(boxsize))] = "o"
            boxesdrawn += 1
        else:
            #sRAW RECTANGLE AROUND CLEAR PATH
            cv2.rectangle(roomimg, (i,j), (i+int(boxsize), j+int(boxsize)),(0,255,255))
            
            
            #Make sure i and j are not switch up!
            #Creates Node if there is a clear path
            newNode = Node(xcoordinate = i/int(boxsize), ycoordinate = j/int(boxsize))

           #Add node to Matrix
            Matrix[int(j/int(boxsize))][int(i/int(boxsize))] = newNode



        box_num += 1
        
def draw_line(x1,y1, x2,y2):
    #convert Matrix point to points on the image
    x1 = int (x1 * int(boxsize))
    #deal with the center instead of the top left corner
    x1 = x1 + int(int(boxsize)/2)
    
    y1 = int (y1 * int(boxsize))
    y1 = y1 + int(int(boxsize)/2)
    
    x2 = int(x2 * int(boxsize))
    x2 = x2 + int(int(boxsize)/2)

    y2 = int(y2 * int(boxsize))
    y2 = y2 + int(int(boxsize)/2)


    cv2.line(roomimg,(x1,y1), (x2,y2), (255,255,255), 2)


def print_matrix():
    f = open('obstaclemap.txt', 'w')
    f.write('\n'.join([''.join(['{:4}'.format(item) for item in row]) 
      for row in Matrix]))
    f.close()

def listToLinkedList(lst):
    assert len(lst) > 0
    if len(lst) == 1:
        return LinkedList(lst[0])
    else:
        return LinkedList(lst[0], listToLinkedList(lst[1:]))



def create_adjacancy_list(node,x,y):
    
    possible_next_steps = []
    
    #Make sure current node is not an obstacle
    if node != "o" and x >=0 and y>= 0:
        possible_next_steps.append(node)
    else:
        return
    
    #check all the neighbors of node and see if they are clear paths
    try:
        north = Matrix[y-1][x]
        if north != "o" and x >= 0 and (y-1) >=0:
            possible_next_steps.append(north)
    except IndexError:
        print ("out of index")
    try:
        east = Matrix[y][x+1]
        if east != "o" and (x+1) >= 0 and y >=0:
            possible_next_steps.append(east)
    except IndexError:
        print ("out of index")
    
    try:
        south = Matrix[y+1][x] 
        if south != "o" and x >= 0 and (y+1) >=0:
            possible_next_steps.append(south)
    except IndexError:
        print ("out of index")
        
    try:
        west = Matrix[y][x-1]
        if west != "o" and (x-1) >= 0 and (y) >=0:
            possible_next_steps.append(west)
    except IndexError:
        print ("out of index")

    try:
        north_east = Matrix[y-1][x+1]
        if north_east != "o" and (x+1) >= 0 and (y-1) >=0:
            possible_next_steps.append(north_east)
    except IndexError:
        print ("out of index")

    try:
        north_west = Matrix[y-1][x-1]
        if north_west != "o" and (x-1) >= 0 and (y-1) >=0:
            possible_next_steps.append(north_west)
    except IndexError:
        print ("out of index")
    try:
        south_east = Matrix[y+1][x+1]
        if south_east != "o" and (x+1) >= 0 and (y+1) >=0:
            possible_next_steps.append(south_east)
    except IndexError:
        print ("out of index")
    try:
        south_west = Matrix[y+1][x-1]
        if south_west != "o" and (x-1) >= 0 and (y+1) >=0:
            possible_next_steps.append(south_west)
    except IndexError:
        print ("out of index")


#check if there are any possible next steps
    if not possible_next_steps:
        print ("There are no possible next steps")
        return
    
    #turn array of neighbors into linked list
    adjacancy_list.append(listToLinkedList(possible_next_steps))
    
#len(Matrix[0]) = traverse column
##len(Matrix) = traverse row
for i in range (0,len(Matrix[0])):
    for j in range (0,len(Matrix)):
        create_adjacancy_list(Matrix[i][j],i,j)


#print matrix
#print_matrix()
    
#save image file
#cv2.imwrite('roomimg.jpg', roomimg)
    
#display image
cv2.imshow("image", roomimg)


if cv2.waitKey(0) & 0xff == 27:
    cv2.destroyAllWindows()